
import os
from sys import argv as arguments

# The sc to work on
default_sc = "./ultraswap.sol"
sc = None

# If specified, this program can be ran with a custom smart contract argument
if len(arguments) < 2:
    sc = default_sc
else:
    sc = arguments[1]

# Opening the file
sc_buffer = open(sc, "r").readlines()

# Initial variables definition
methods = {}
current_method = {}
writing_method = False
is_intro = False
current_contract = ""

# Parsing the whole contract line by line
for line in sc_buffer:
    line = line.strip()
    
    # If found, contract name is stored
    if line.startswith("contract"):
        current_contract = line.split("contract ")[1]
        if " " in current_contract:
            current_contract = current_contract.split(" ")[0]
        print("Current contract: " + current_contract)
        current_method["contract"] = current_contract
    
    # Method documentation starts here
    # NOTE: First method and further ones are treated differently to catch them all
    if writing_method and ("/// @dev" in line):
        methods[current_method["name"]] = current_method
        current_method["writable"] = "true"
        current_method = {
            "contract": current_contract,
            "params": {},
            "return": {}
        }
        current_method["description"] = line.replace("/// @dev ", "")
    elif not writing_method and ("/// @dev" in line):
        writing_method = True
        current_method["writable"] = "true"
        current_method = {
            "contract": current_contract,
            "params": {},
            "return": {}
        }
        current_method["description"] = line.replace("/// @dev ", "")
    # Method parameters are stored here
    elif writing_method and ("/// @param" in line):
        clean_line = line.replace("/// @param ", "")
        current_method["params"][clean_line.split(" ")[0]] = clean_line.replace(clean_line.split(" ")[1] + " ", "")
    # Method return values are stored here
    elif writing_method and ("/// @return" in line):
        clean_line = line.replace("/// @return ", "")
        current_method["return"][clean_line.split(" ")[0]] = clean_line.replace(clean_line.split(" ")[1] + " ", "")
    # Notes made by the developer are stored here
    elif writing_method and ("/// @notice" in line):
        current_method["note"] = line.replace("/// @notice ", "")
    # Method name is stored here
    elif writing_method and ("function" in line):
        name = line.split("function ")[1].split("(")[0].strip()
        current_method["name"] = name
        # If in the same line, visibility is stored here
        if "{" in line:
            visibility = "None"
            if " public" in line: 
                visibility = "public"
            elif " private" in line or "private\n" in line:
                visibility = "private"
            elif " internal" in line or "internal\n" in line:
                visibility = "internal"
            elif " external" in line or "external\n" in line:
                visibility = "external"
            # If in the same line, write or read status is stored here
            if " view" in line or "view\n" in line:
                current_method["writable"] = "false"
        else: 
            is_intro = True
            visibility = "None"
            readability = "true"
    # If not in the same line, visibility and/or read/write status are stored here
    elif writing_method and is_intro and not "function" in line:
        if visibility == "None":
            print("Visibility unset")
            if "public" in line : 
                visibility = "public"
            elif "private" in line :
                visibility = "private"
            elif "internal" in line :
                visibility = "internal"
            elif "external" in line :
                visibility = "external"
            current_method["visibility"] = visibility
        if readability == "true":
            if "view" in line or "view\n" in line:
                print("Read method")
                readability = "false"
                current_method["writable"] = "false"
        # Closing the method documentation
        if "{" in line:
            is_intro = False
            visibility = "None"
            readability = "true"
 
# Writing the documentation to a file
methods[current_method["name"]] = current_method
with open("methods.json", "w+") as f:
    f.write(str(methods))
    
# HTML generation
html = "<!DOCTYPE html>\n"
html += "<html>\n"
html += "<head>\n"
# Loading fonts
html += "<link href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap\" rel=\"stylesheet\">\n"
html += "<title>Documentation generated by PicoGen</title>\n"
html += "</head>\n"
html += "<body>\n"
# Using fonts in the page
html += "<style>\n"
html += "body {\n"
html += "font-family: 'Roboto', sans-serif;\n"
html += "}\n"
html += '''.styled-table {
    border-collapse: collapse;
    margin: 25px 0;
    font-size: 0.9em;
    font-family: sans-serif;
    min-width: 400px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
}

.styled-table thead tr {
    background-color: #009879;
    color: #ffffff;
    text-align: left;
}

.styled-table th,
.styled-table td {
    padding: 12px 15px;
}

.styled-table tbody tr {
    border-bottom: 1px solid #dddddd;
}

.styled-table tbody tr:nth-of-type(even) {
    background-color: #f3f3f3;
}

.styled-table tbody tr:last-of-type {
    border-bottom: 2px solid #009879;
}\n'''
html += "</style>\n"

html += "<h4>Documentation generated by PicoGen</h4>\n"
html += "<h1>" + sc + "</h1>\n"
html += "<br><hr><br>\n"
html += "<h2>Methods</h2>\n"
html += "<br>\n"

for method in methods:
    # Create the table
    html += "<table class=\"styled-table\">\n"
    html += "<tr>\n"
    html += "<td>\n"
    html += "Name\n"
    html += "</td>\n"
    html += "<td>\n"
    html += "Contract\n"
    html += "</td>\n"
    html += "<td>\n"
    html += "Description\n"
    html += "</td>\n"
    html += "<td>\n"
    html += "Visibility\n"
    html += "</td>\n"
    html += "<td>\n"
    html += "Is writable\n"
    html += "</td>\n"
    html += "<td>\n"
    html += "Parameters\n"
    html += "</td>\n"
    html += "<td>\n"
    html += "Return values\n"
    html += "</td>\n"
    html += "<td>\n"
    html += "Notes\n"
    html += "</td>\n"
    html += "</tr>\n"
    html += "<tr>\n"
    html += "<td>" + method + "</td>\n"
    html += "<td>" + methods[method]["contract"] + "</td>\n"
    properties = methods[method]
    html += "<td>" + properties["description"] + "</td>\n"
    html += "<td>" + properties["visibility"] + "</td>\n"
    html += "<td>" + properties["writable"] + "</td>\n"
    html += "<td>\n"
    for param in properties["params"]:
        html += "<p>" + param + ": " + properties["params"][param] + "</p>\n"
    html += "</td>\n"
    html += "<td>\n"
    for ret in properties["return"]:
        html += "<p>" + ret + ": " + properties["return"][ret] + "</p>\n"
    html += "</td>\n"  
    html += "<td>\n"
    try:
        html += "<p>" + properties["note"] + "</p>\n"
    except:
        pass
    html += "</td>\n"
    html += "</tr>\n"
    html += "</table>\n"
    html += "<hr>\n"  
html += "</body>\n"
html += "</html>\n"

with open("documentation.html", "w+") as f:
    f.write(html)
    
os.remove("methods.json")